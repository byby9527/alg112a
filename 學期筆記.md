# 第一周:

### 02-演算法/01-複雜度/01-bigO/infinite.py:
### 此程式碼是不可執行的用寬鬆的角度來看複雜度是無限大，但以嚴格的角度來說 可以執行的程式才是演算法，因此這個程式不是演算法
```
while (True):
    pass
```
## 教學資料:https://www.hello-algo.com/chapter_computational_complexity/time_complexity/#234

### 常數階O(1)不管常數多大，最後結果都是為big O(1)
### 線性階O(n)，裡面有一層迴圈，迴圈數量是n，結果為big O(n)
### 平方階O(n^2)，裡面有兩層迴圈，結果為big O(n^2)，以下是範例
```

正確例子(2層迴圈):
for i in range(n):
        for j in range(n):

錯誤例子(2個迴圈):
for i in range(n):
for j in range(n):

```
### 指數階O(2^n)此算法不太好，數值會依照次方數而不斷變大
### 對數階O(log n) 與指數階相反，對數階反映了每輪縮減到一半的情况，例如:二分搜尋法
### 線性對數階O(n log n) 是很多排序法的極限
### 階層階O(n!)给定n個互不重複的元素，求其所有可能的排列方案
59.52



# 第二周:













# 第8周:
## 貪婪法:
### 其核心思想是在每一步的決策中，都選擇當前能帶來最優或最有利的選擇，從而希望最終得到最優的結果。
### 舉例:
### 最小生成樹問題:最小生成樹是指一張圖中所有頂點都連通的一個子圖，其邊的權值之和最小。
### 算法步驟:
```
1.從圖中任意選擇一個頂點作為起點，將其加入生成樹。
2.遍歷圖中所有與生成樹相連的邊，找到權值最小的邊。
3.如果加入該邊不會產生環，則將其加入生成樹。
4.重複步驟 2 和 3，直到所有頂點都加入生成樹。
```
### 貪婪算法可以用來解決最小生成樹問題，其基本思想是：每次都選擇與現有生成樹相連的邊，其權值最小的邊，直到所有頂點都連通。


### 哈夫曼編碼:
### 哈夫曼編碼是一種數據壓縮算法，其基本思想是：將字符按照其出現頻率進行排序，頻率最高的字符賦予最短的編碼，頻率最低的字符賦予最長的編碼。
### 算法步驟:
```
1.將字符按照其出現頻率進行排序，頻率最高的字符在最前面。
2.將最前面的兩個字符合并成一個新的字符，其出現頻率為兩個字符出現頻率之和。
3.重複步驟 2，直到所有字符都被合并成一個字符。
4.給每個字符分配一個編碼，編碼的長度等於該字符在哈夫曼樹中的路徑長度。
```
### 貪婪算法可以用來生成哈夫曼樹，哈夫曼樹是一種二叉樹，其每個葉子節點代表一個字符，每條邊的權值代表該字符的出現頻率。


### 最後，貪婪法並不能保證得到最優解，但在許多問題中，貪婪法可以得到近似最優解，且具有較高的效率。



## Graph:
### 繪圖





